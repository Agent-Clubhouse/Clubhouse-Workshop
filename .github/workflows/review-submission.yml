name: Review Community Submission

on:
  pull_request:
    paths:
      - 'registry/registry.json'

jobs:
  review:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout PR
        uses: actions/checkout@v4

      - name: Checkout base
        uses: actions/checkout@v4
        with:
          ref: ${{ github.base_ref }}
          path: base

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Detect new or updated plugins
        id: detect
        run: |
          node -e "
            const fs = require('fs');
            const prRegistry = JSON.parse(fs.readFileSync('registry/registry.json', 'utf8'));
            const basePath = 'base/registry/registry.json';
            const baseRegistry = fs.existsSync(basePath)
              ? JSON.parse(fs.readFileSync(basePath, 'utf8'))
              : { plugins: [] };

            const baseIds = new Set(baseRegistry.plugins.map(p => p.id));
            const newPlugins = prRegistry.plugins.filter(p => !baseIds.has(p.id));
            const updatedPlugins = prRegistry.plugins.filter(p => {
              const base = baseRegistry.plugins.find(b => b.id === p.id);
              return base && base.latest !== p.latest;
            });

            const changed = [...newPlugins, ...updatedPlugins];
            console.log('New plugins:', newPlugins.map(p => p.id).join(', ') || 'none');
            console.log('Updated plugins:', updatedPlugins.map(p => p.id).join(', ') || 'none');

            fs.writeFileSync('/tmp/changed-plugins.json', JSON.stringify(changed));
          "

      - name: Validate changed plugins
        run: |
          node -e "
            const fs = require('fs');
            const https = require('https');
            const http = require('http');
            const crypto = require('crypto');

            const plugins = JSON.parse(fs.readFileSync('/tmp/changed-plugins.json', 'utf8'));
            if (plugins.length === 0) {
              console.log('No new or updated plugins to validate.');
              process.exit(0);
            }

            const errors = [];
            const warnings = [];

            for (const plugin of plugins) {
              console.log('\nValidating:', plugin.id);

              // Check ID format
              if (!/^[a-z0-9-]+$/.test(plugin.id)) {
                errors.push(plugin.id + ': Invalid ID format');
              }

              // Check reserved prefix
              if (plugin.id.startsWith('example-')) {
                errors.push(plugin.id + ': The example- prefix is reserved for official examples');
              }

              // Check required fields
              const required = ['name', 'description', 'author', 'source', 'repo', 'latest', 'releases'];
              for (const field of required) {
                if (!(field in plugin)) {
                  errors.push(plugin.id + ': Missing required field: ' + field);
                }
              }

              // Check latest exists in releases
              if (plugin.releases && !(plugin.latest in plugin.releases)) {
                errors.push(plugin.id + ': Latest version ' + plugin.latest + ' not in releases');
              }

              // Check permissions for sensitive ones
              if (plugin.releases) {
                for (const [version, release] of Object.entries(plugin.releases)) {
                  const perms = release.permissions || [];
                  if (perms.includes('files.external')) {
                    warnings.push(plugin.id + '@' + version + ': Uses files.external permission — requires justification');
                  }
                  if (perms.includes('process')) {
                    warnings.push(plugin.id + '@' + version + ': Uses process permission — requires justification');
                  }
                  if (perms.includes('terminal')) {
                    warnings.push(plugin.id + '@' + version + ': Uses terminal permission — requires justification');
                  }
                }
              }
            }

            if (warnings.length > 0) {
              console.log('\n⚠ Warnings:');
              warnings.forEach(w => console.log('  -', w));
            }

            if (errors.length > 0) {
              console.log('\n✗ Errors:');
              errors.forEach(e => console.log('  -', e));
              process.exit(1);
            }

            console.log('\n✓ All validations passed');
          "

      - name: Check asset URLs are reachable
        run: |
          node -e "
            const fs = require('fs');
            const plugins = JSON.parse(fs.readFileSync('/tmp/changed-plugins.json', 'utf8'));

            async function checkUrl(url) {
              try {
                const res = await fetch(url, { method: 'HEAD', redirect: 'follow' });
                return res.ok;
              } catch {
                return false;
              }
            }

            (async () => {
              let allOk = true;
              for (const plugin of plugins) {
                for (const [version, release] of Object.entries(plugin.releases || {})) {
                  if (!release.asset) continue;
                  const ok = await checkUrl(release.asset);
                  if (ok) {
                    console.log('✓', plugin.id + '@' + version, '— asset reachable');
                  } else {
                    console.log('✗', plugin.id + '@' + version, '— asset NOT reachable:', release.asset);
                    allOk = false;
                  }
                }
              }
              if (!allOk) {
                console.log('\nSome asset URLs are not reachable. This may be expected if the release has not been published yet.');
              }
            })();
          "
