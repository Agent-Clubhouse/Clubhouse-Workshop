name: Release Plugin

on:
  push:
    tags:
      - '*-v*'  # e.g., example-hello-world-v0.1.0, code-review-v1.0.0
  workflow_dispatch:
    inputs:
      tag:
        description: 'Tag to release (e.g., code-review-v0.1.0)'
        required: true

permissions:
  contents: write
  pull-requests: write

# Serialize registry updates so concurrent releases don't conflict
concurrency:
  group: registry-update
  cancel-in-progress: false

jobs:
  release:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Parse tag
        id: tag
        run: |
          if [ -n "${{ github.event.inputs.tag }}" ]; then
            TAG="${{ github.event.inputs.tag }}"
            git fetch --tags
            git checkout "$TAG"
          else
            TAG="${GITHUB_REF#refs/tags/}"
          fi
          # Extract plugin ID and version from tag like "code-review-v0.1.0"
          PLUGIN_ID=$(echo "$TAG" | sed 's/-v[0-9].*//')
          VERSION=$(echo "$TAG" | sed 's/.*-v//')
          echo "tag=$TAG" >> "$GITHUB_OUTPUT"
          echo "plugin_id=$PLUGIN_ID" >> "$GITHUB_OUTPUT"
          echo "version=$VERSION" >> "$GITHUB_OUTPUT"
          echo "plugin_dir=plugins/$PLUGIN_ID" >> "$GITHUB_OUTPUT"

      - name: Verify plugin directory exists
        run: |
          if [ ! -d "${{ steps.tag.outputs.plugin_dir }}" ]; then
            echo "Error: Plugin directory ${{ steps.tag.outputs.plugin_dir }} not found"
            exit 1
          fi

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install and build
        working-directory: ${{ steps.tag.outputs.plugin_dir }}
        run: |
          npm install
          npm run build

      - name: Run tests
        working-directory: ${{ steps.tag.outputs.plugin_dir }}
        run: |
          if grep -q '"test"' package.json; then
            npm test
          else
            echo "No test script found, skipping"
          fi

      - name: Validate manifest
        run: node scripts/validate-manifest.mjs "${{ steps.tag.outputs.plugin_dir }}" --strict

      - name: Verify version matches tag
        working-directory: ${{ steps.tag.outputs.plugin_dir }}
        run: |
          MANIFEST_VERSION=$(node -p "JSON.parse(require('fs').readFileSync('manifest.json','utf8')).version")
          TAG_VERSION="${{ steps.tag.outputs.version }}"
          if [ "$MANIFEST_VERSION" != "$TAG_VERSION" ]; then
            echo "ERROR: manifest.json version ($MANIFEST_VERSION) does not match tag version ($TAG_VERSION)"
            exit 1
          fi
          MANIFEST_ID=$(node -p "JSON.parse(require('fs').readFileSync('manifest.json','utf8')).id")
          TAG_ID="${{ steps.tag.outputs.plugin_id }}"
          if [ "$MANIFEST_ID" != "$TAG_ID" ]; then
            echo "ERROR: manifest.json id ($MANIFEST_ID) does not match tag id ($TAG_ID)"
            exit 1
          fi

      - name: Create release zip
        id: zip
        working-directory: ${{ steps.tag.outputs.plugin_dir }}
        run: |
          ZIP_NAME="${{ steps.tag.outputs.tag }}.zip"
          zip -r "../../$ZIP_NAME" manifest.json dist/ README.md
          echo "zip_path=$ZIP_NAME" >> "$GITHUB_OUTPUT"
          SHA=$(sha256sum "../../$ZIP_NAME" | cut -d' ' -f1)
          echo "sha256=$SHA" >> "$GITHUB_OUTPUT"
          SIZE=$(wc -c < "../../$ZIP_NAME" | tr -d ' ')
          echo "size=$SIZE" >> "$GITHUB_OUTPUT"

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.tag.outputs.tag }}
          name: "${{ steps.tag.outputs.plugin_id }} v${{ steps.tag.outputs.version }}"
          body: |
            ## ${{ steps.tag.outputs.plugin_id }} v${{ steps.tag.outputs.version }}

            ### Install
            ```bash
            cp -r plugins/${{ steps.tag.outputs.plugin_id }} ~/.clubhouse/plugins/
            ```

            Or download the zip and extract to `~/.clubhouse/plugins/${{ steps.tag.outputs.plugin_id }}/`.
          files: ${{ steps.zip.outputs.zip_path }}

      - name: Update registry
        run: |
          node -e "
            const fs = require('fs');

            // Re-read registry from main (we may be on a tag checkout)
            const registry = JSON.parse(fs.readFileSync('registry/registry.json', 'utf8'));
            const pluginId = '${{ steps.tag.outputs.plugin_id }}';
            const version = '${{ steps.tag.outputs.version }}';
            const manifest = JSON.parse(fs.readFileSync('${{ steps.tag.outputs.plugin_dir }}/manifest.json', 'utf8'));

            let plugin = registry.plugins.find(p => p.id === pluginId);
            if (!plugin) {
              plugin = {
                id: pluginId,
                name: manifest.name,
                description: manifest.description,
                author: manifest.author,
                official: manifest.official === true,
                repo: 'https://github.com/${{ github.repository }}',
                path: 'plugins/' + pluginId,
                tags: [],
                latest: version,
                releases: {}
              };
              registry.plugins.push(plugin);
            }

            // Update metadata from manifest (in case name/description changed)
            plugin.name = manifest.name;
            plugin.description = manifest.description;
            plugin.author = manifest.author;
            plugin.latest = version;
            plugin.releases[version] = {
              api: manifest.engine.api,
              asset: 'https://github.com/${{ github.repository }}/releases/download/${{ steps.tag.outputs.tag }}/${{ steps.tag.outputs.tag }}.zip',
              sha256: '${{ steps.zip.outputs.sha256 }}',
              permissions: manifest.permissions || [],
              size: parseInt('${{ steps.zip.outputs.size }}', 10)
            };

            // Sync supportedApis from sdk/versions.json
            const versionsPath = 'sdk/versions.json';
            if (fs.existsSync(versionsPath)) {
              const sdkVersions = JSON.parse(fs.readFileSync(versionsPath, 'utf8'));
              const activeVersions = Object.entries(sdkVersions.versions)
                .filter(([_, e]) => e.status !== 'removed')
                .map(([v]) => v);
              registry.supportedApis = {
                latest: sdkVersions.latest,
                minimum: sdkVersions.minimum,
                versions: activeVersions
              };
            }

            registry.updated = new Date().toISOString();
            fs.writeFileSync('registry/registry.json', JSON.stringify(registry, null, 2) + '\n');
          "

          # Validate the registry we just generated
          node scripts/validate-registry.mjs

      - name: Create and merge registry PR
        run: |
          # Save updated registry before switching branches
          cp registry/registry.json /tmp/registry-updated.json

          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          BRANCH="registry-update/${{ steps.tag.outputs.tag }}"

          git fetch origin main
          git checkout -b "$BRANCH" origin/main

          # Apply the updated registry
          cp /tmp/registry-updated.json registry/registry.json
          git add registry/registry.json
          git diff --cached --quiet && echo "No registry changes" && exit 0

          git commit -m "registry: update ${{ steps.tag.outputs.plugin_id }} to v${{ steps.tag.outputs.version }}"
          git push --force origin "$BRANCH"

          PR_URL=$(gh pr create \
            --title "registry: update ${{ steps.tag.outputs.plugin_id }} to v${{ steps.tag.outputs.version }}" \
            --body "Automated registry update from release pipeline." \
            --base main \
            --head "$BRANCH")
          echo "Created PR: $PR_URL"

          # Immediately merge (0 approvals required, CODEOWNER review disabled)
          gh pr merge "$PR_URL" --squash --delete-branch
        env:
          GH_TOKEN: ${{ github.token }}
