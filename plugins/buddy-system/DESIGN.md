# Buddy System - High-Level Design Document

**Plugin:** `buddy-system`
**Scope:** `app` (rail item — cross-project by nature)
**SDK Version:** `0.6` (required for `agentConfig` cross-project APIs)
**Author:** Clubhouse Workshop
**Date:** 2026-02-22

---

## 1. Problem Statement

Teams building features that span multiple codebases (client, mobile, server) face integration drift. Each agent or team member implements to spec independently, but design changes that surface during development create subtle misalignments. The result: long-tail integration timelines, post-release bugs, and wasted rework.

**Buddy System** solves this by enabling groups of durable agents — potentially from different projects — to collaborate on a shared deliverable with coordinated planning, execution, and real-time communication.

---

## 2. User Experience Overview

### 2.1 Rail Item

A new **Buddy Groups** item appears in the app sidebar rail. Clicking it opens the plugin's main panel showing all buddy groups.

### 2.2 Group Lifecycle

1. **Create** — User clicks "+ New Group". A random name is generated (`{adjective}-{group-word}`, e.g. `adventure-squad`, `mystical-troupe`). The name is editable.
2. **Add Members** — User adds durable agents from any open project. At add-time, the user provides text context about the agent's role and its project. The first agent added becomes the **group leader** (reassignable later).
3. **Assign Work** — User gives a mission to the group leader via a text prompt. The leader examines the work, the group composition, and produces a plan with deliverables assigned to each member (including optionally itself).
4. **Execute** — The plugin kicks off execution. Agents communicate status, findings, and changes through a shared directory. The plugin UI shows live progress.
5. **Complete / Disband** — When all deliverables are done, the group can be archived or disbanded.

---

## 3. Architecture

### 3.1 Plugin Shape

```
buddy-system/
├── manifest.json          # App-scoped, v0.6, extensive permissions
├── package.json
├── tsconfig.json
├── src/
│   ├── main.tsx           # activate(), MainPanel, SidebarPanel (if sidebar-content)
│   ├── types.ts           # BuddyGroup, GroupMember, Assignment, etc.
│   ├── state/
│   │   ├── groups.ts      # Group CRUD, global storage layer
│   │   └── comms.ts       # Shared communication read/write
│   ├── orchestration/
│   │   ├── planner.ts     # Leader planning orchestration
│   │   ├── executor.ts    # Member execution orchestration
│   │   └── monitor.ts     # Polling loop for status updates
│   ├── config/
│   │   ├── injector.ts    # agentConfig injection logic
│   │   └── skills.ts      # Skill templates for group members
│   ├── names.ts           # Random name generator
│   └── ui/
│       ├── GroupList.tsx   # List of all groups
│       ├── GroupDetail.tsx # Single group view
│       ├── MemberCard.tsx  # Agent card with status
│       ├── PlanView.tsx    # Plan/deliverables view
│       └── CommsLog.tsx    # Communication feed
├── dist/
│   └── main.js
└── tests/
    ├── groups.test.ts
    ├── orchestration.test.ts
    └── names.test.ts
```

### 3.2 Manifest

```json
{
  "id": "buddy-system",
  "name": "Buddy System",
  "version": "0.1.0",
  "description": "Collaborative agent groups for cross-project deliverables",
  "author": "Clubhouse Workshop",
  "engine": { "api": 0.6 },
  "scope": "app",
  "main": "./dist/main.js",
  "permissions": [
    "logging",
    "storage",
    "agents",
    "projects",
    "notifications",
    "commands",
    "widgets",
    "badges",
    "navigation",
    "agent-config",
    "agent-config.cross-project",
    "agent-config.permissions"
  ],
  "contributes": {
    "railItem": {
      "label": "Buddy Groups",
      "icon": "<svg>...</svg>",
      "position": "top"
    },
    "commands": [
      { "id": "buddy-system.new-group", "title": "Create Buddy Group" },
      { "id": "buddy-system.assign-work", "title": "Assign Work to Group" }
    ],
    "help": {
      "topics": [
        {
          "id": "overview",
          "title": "Buddy System",
          "content": "# Buddy System\n\nCreate groups of agents across projects to collaborate on shared deliverables..."
        }
      ]
    }
  }
}
```

### 3.3 Data Model

```typescript
interface BuddyGroup {
  id: string;                    // UUID
  name: string;                  // e.g. "adventure-squad"
  createdAt: string;             // ISO timestamp
  status: "idle" | "planning" | "executing" | "complete" | "archived";
  leaderId: string;              // GroupMember.id
  members: GroupMember[];
  mission?: string;              // The work assigned by the user
  plan?: GroupPlan;              // Generated by the leader
}

interface GroupMember {
  id: string;                    // UUID (not the agentId — agents may restart)
  agentId: string;               // Clubhouse agent ID at time of addition
  agentName: string;             // Display name
  projectId: string;             // Which project this agent belongs to
  projectName: string;           // Display name of project
  context: string;               // User-provided context about this agent/project
  isLeader: boolean;
  status: "idle" | "working" | "blocked" | "done" | "error";
  assignmentId?: string;         // Which deliverable they're working on
}

interface GroupPlan {
  summary: string;               // High-level approach
  deliverables: Deliverable[];
  createdAt: string;
}

interface Deliverable {
  id: string;
  title: string;
  description: string;
  assigneeId: string;            // GroupMember.id
  status: "pending" | "in-progress" | "review" | "complete" | "blocked";
  dependencies?: string[];       // Other Deliverable.ids this depends on
}

interface CommMessage {
  id: string;
  groupId: string;
  fromMemberId: string;          // GroupMember.id or "system"
  timestamp: string;
  type: "status" | "finding" | "change" | "question" | "plan" | "complete";
  content: string;
  metadata?: Record<string, unknown>;
}
```

---

## 4. Storage Strategy

### 4.1 Plugin Storage (via `api.storage.global`)

All group data persists in global storage (`~/.clubhouse/plugin-data/buddy-system/`):

| Key Pattern | Content |
|---|---|
| `groups/index` | Array of group IDs |
| `groups/{groupId}` | Full `BuddyGroup` object |
| `comms/{groupId}/log` | Array of `CommMessage` (append-only, recent-first) |
| `comms/{groupId}/latest` | Timestamp of most recent message |

### 4.2 Shared Communication Directory

For agent-to-agent communication, we use a **filesystem-based approach** rather than storage API, because agents (as Claude Code instances) can read/write files directly but cannot call plugin storage APIs.

**Location:** `~/.clubhouse/buddy-system/{groupId}/`

```
~/.clubhouse/buddy-system/{groupId}/
├── plan.md                      # The leader's plan (human + agent readable)
├── assignments/
│   ├── {memberId}.md            # Each member's assignment details
│   └── ...
├── status/
│   ├── {memberId}.json          # Each member's latest status
│   └── ...
├── comms/
│   ├── {timestamp}-{memberId}.md  # Individual messages
│   └── ...
└── shared/
    ├── decisions.md             # Running log of design decisions
    └── interfaces.md            # Shared interface contracts
```

**Why filesystem over storage API:**
- Agents are CLI tools with filesystem access — they can `cat`, `read`, and `write` files
- The injected skill teaches agents these paths
- Plugin reads these same files to update its UI
- No need for a bespoke IPC mechanism

**Plugin syncs filesystem ↔ UI:**
The plugin's monitor polling loop reads from this directory and updates the UI. When the plugin needs to write (e.g., initial plan placement), it writes directly.

---

## 5. Agent Orchestration

### 5.1 Config Injection Pipeline

When an agent is added to a group, the plugin injects configuration into that agent's project using the `agentConfig` cross-project API:

#### Injected Skill: `buddy-system-member`

```markdown
# Buddy System Member

You are part of a buddy group: **{groupName}**.

## Your Role
- Member ID: {memberId}
- Group Leader: {leaderName} ({leaderProjectName})
- Your Assignment: See `~/.clubhouse/buddy-system/{groupId}/assignments/{memberId}.md`

## Communication Protocol
- **Check for updates:** Read `~/.clubhouse/buddy-system/{groupId}/comms/` periodically
- **Report status:** Write JSON to `~/.clubhouse/buddy-system/{groupId}/status/{memberId}.json`
- **Share findings:** Write to `~/.clubhouse/buddy-system/{groupId}/comms/{timestamp}-{memberId}.md`
- **Design decisions:** Append to `~/.clubhouse/buddy-system/{groupId}/shared/decisions.md`
- **Interface contracts:** Update `~/.clubhouse/buddy-system/{groupId}/shared/interfaces.md`

## Status Format
{
  "status": "working" | "blocked" | "done" | "error",
  "deliverableId": "...",
  "progress": "brief description of current state",
  "blockers": ["any blockers"],
  "lastCheckin": "ISO timestamp"
}

## Guidelines
- Check the shared directory for updates from other group members before starting work
- When you make a design decision that affects others, write it to decisions.md
- When you define or change an interface, update interfaces.md
- Report status after completing each major step
- If blocked on another member's work, write a message and note the blocker in your status
```

#### Appended Instructions

The plugin appends project instructions via `agentConfig.appendInstructions()`:

```
You are participating in a Buddy System group "{groupName}". Check your assignment
at ~/.clubhouse/buddy-system/{groupId}/assignments/{memberId}.md and follow the
buddy-system-member skill for communication protocols.
```

#### Permission Rules

Via `agentConfig.addPermissionAllowRules()`, grant filesystem access:

```
Bash(read:~/.clubhouse/buddy-system/**)
Bash(write:~/.clubhouse/buddy-system/{groupId}/**)
```

### 5.2 Execution Flow

```
User assigns mission to group
         │
         ▼
Plugin resumes leader agent with planning mission
  api.agents.resume(leaderId, { mission: planningPrompt })
         │
         ▼
Leader wakes, reads group context, writes plan.md
  (skill teaches it the shared directory path)
         │
         ▼
Plugin monitor detects plan.md written
  (polling loop checks filesystem)
         │
         ▼
Plugin parses plan, creates assignment files
  writes ~/.clubhouse/buddy-system/{groupId}/assignments/{memberId}.md
         │
         ▼
Plugin resumes each member agent with their assignment
  api.agents.resume(memberId, { mission: assignmentPrompt })
         │
         ▼
Members execute, writing status + comms to shared directory
         │
         ▼
Plugin monitor polls status files, updates UI
  shows progress, comms log, deliverable status
         │
         ▼
Members complete → Plugin detects all done → Group marked complete
```

### 5.3 Leader Planning Prompt

When the user assigns work, the plugin constructs a prompt for the leader:

```
You are the leader of buddy group "{groupName}". You have been given the following mission:

{userMission}

Your group members are:
{memberList with context}

Create a plan that:
1. Breaks the mission into major deliverables
2. Assigns each deliverable to the most appropriate group member
3. Identifies dependencies between deliverables
4. Defines shared interfaces or contracts where cross-project integration is needed

Write your plan to: ~/.clubhouse/buddy-system/{groupId}/plan.md

Format the plan as markdown with YAML frontmatter containing structured assignment data:
---
deliverables:
  - id: d1
    title: "..."
    assignee: "{memberId}"
    dependencies: []
  - id: d2
    title: "..."
    assignee: "{memberId}"
    dependencies: ["d1"]
---
```

---

## 6. API Feasibility Assessment

### 6.1 What Works Well

| Capability | API | Assessment |
|---|---|---|
| App-scoped rail item | `contributes.railItem` | Direct support, no issues |
| List agents across projects | `api.agents.list()` | Returns all agents with `projectId` — works perfectly |
| List all projects | `api.projects.list()` | Direct support |
| Wake agents with missions | `api.agents.resume(id, { mission })` | **Key enabler.** Resume accepts an optional mission string |
| Monitor agent status | `api.agents.onStatusChange()`, `getDetailedStatus()` | Real-time monitoring works |
| Inject skills into agents | `api.agentConfig.injectSkill()` | Core to the approach, v0.6 |
| Cross-project config | `agentConfig` with `{ projectId }` | Requires `agent-config.cross-project`, bilateral consent |
| Inject instructions | `api.agentConfig.appendInstructions()` | Gives agents context about their role |
| Grant permissions | `api.agentConfig.addPermissionAllowRules()` | Ensures agents can access shared directory |
| Global storage | `api.storage.global` | Plugin state persistence |
| Agent display widgets | `AgentAvatar`, `SleepingAgent` | Rich UI for showing group members |
| Badges | `api.badges.set()` | Show unread comms count on rail item |

### 6.2 Challenges and Mitigations

| Challenge | Severity | Mitigation |
|---|---|---|
| **No push-based inter-agent comms** | Medium | Filesystem-based communication + injected skill teaches agents to check shared directory. Agents won't be "notified" of new messages — they read on their own initiative or when the plugin resumes them. |
| **No file watching API** | Medium | Plugin uses a polling loop (e.g., every 5-10 seconds) to check the shared directory for changes. This is the same pattern used by many real-world tools. |
| **Agent must be sleeping to resume** | Medium | If agent is already running, cannot redirect it. Plugin must wait for agent to reach a resting state. UI should show "waiting for agent to become available" state. |
| **Bilateral consent for cross-project config** | Low | Plugin must be installed/enabled in each project whose agents participate. This is a reasonable security boundary but requires user setup. Clear onboarding UX needed. |
| **Quick agents can't participate durably** | Low | Buddy groups only accept durable agents. Quick agents are ephemeral by nature and wouldn't benefit from group membership. |
| **Agent identity stability** | Medium | Agents may be killed and recreated with new IDs. GroupMember stores the `agentId` at add-time; if the agent is replaced, the user needs to update the member. Plugin should detect stale agent IDs via `api.agents.list()` and warn. |
| **Plan parsing reliability** | Medium | Leader agent output is unstructured text. Use YAML frontmatter in plan.md for structured data; fall back to plugin presenting the raw plan for user to manually assign if parsing fails. |
| **Shared directory conflicts** | Low | Each member writes only to their own status/assignment subdirectory. `decisions.md` and `interfaces.md` are append-only. Conflict risk is low because agents operate on different projects/files. |

### 6.3 Blockers

| Blocker | Severity | Notes |
|---|---|---|
| **None identified** | — | All required capabilities exist in the v0.6 API. The design is feasible with current APIs. |

The only notable gap is the lack of a push-based communication mechanism between agents, but the filesystem + polling approach is a well-established pattern and sufficient for this use case. A future API enhancement (e.g., `api.agents.sendMessage()`) would improve this but is not required.

---

## 7. Shared Directory vs. MCP Server

An alternative communication approach would be injecting an MCP server via `agentConfig.injectMcpServers()` that provides tools for reading/writing group state. This would give agents a structured API rather than raw filesystem access.

**Pros of MCP approach:**
- Strongly typed tool interface for agents
- Plugin controls all access through the MCP server
- Could implement push notifications via long-polling

**Cons of MCP approach:**
- Requires building and distributing an MCP server binary
- Significantly more complex — MCP server is a separate process
- Overkill for v0.1; filesystem approach is simpler and proven

**Recommendation:** Start with filesystem approach for v0.1. Consider MCP server for v0.2 if the communication patterns prove too loose.

---

## 8. Random Name Generator

Names follow the pattern `{adjective}-{group-word}`:

**Adjectives pool (~30):** bold, brave, bright, clever, cosmic, daring, epic, fierce, golden, grand, hidden, iron, keen, lunar, mighty, noble, prime, proud, rapid, regal, royal, shadow, silent, solar, stellar, swift, valiant, vivid, wild, wise

**Group words pool (~20):** alliance, band, brigade, cadre, clan, cohort, crew, ensemble, force, guild, league, order, pack, patrol, posse, squad, team, troupe, unit, vanguard

This gives ~600 unique combinations. Collision checking against existing group names ensures uniqueness.

---

## 9. UI Wireframe

```
┌─────────────────────────────────────────────────┐
│ Buddy Groups                          [+ New]   │
├─────────────────────────────────────────────────┤
│                                                 │
│  ┌─────────────────────────────────────────┐    │
│  │ ⬢ adventure-squad          [Executing]  │    │
│  │   3 members · 2/5 deliverables done     │    │
│  └─────────────────────────────────────────┘    │
│                                                 │
│  ┌─────────────────────────────────────────┐    │
│  │ ⬢ cosmic-guild                  [Idle]  │    │
│  │   2 members · No work assigned          │    │
│  └─────────────────────────────────────────┘    │
│                                                 │
└─────────────────────────────────────────────────┘

─── Group Detail View ────────────────────────────

┌─────────────────────────────────────────────────┐
│ ← adventure-squad                    [Settings] │
├──────────────┬──────────────────────────────────┤
│ Members      │ Plan & Deliverables              │
│              │                                  │
│ ★ agent-1    │ D1: API schema design    [Done]  │
│   server     │    → agent-1                     │
│   ● working  │                                  │
│              │ D2: Client SDK update  [Working]  │
│ ○ agent-2    │    → agent-2                     │
│   client     │                                  │
│   ● working  │ D3: Mobile bindings   [Pending]  │
│              │    → agent-3 (blocked by D1)     │
│ ○ agent-3    │                                  │
│   mobile     │ D4: Integration tests [Pending]  │
│   ◌ idle     │    → agent-1 (blocked by D2,D3) │
│              │                                  │
├──────────────┴──────────────────────────────────┤
│ Communication Log                               │
│                                                 │
│ [agent-1] Changed auth endpoint from /auth to   │
│           /v2/auth — updating interfaces.md     │
│ [agent-2] Acknowledged auth change, updating    │
│           client SDK accordingly                │
│ [system]  Deliverable D1 marked complete        │
│                                                 │
│ [Assign Work...]                                │
└─────────────────────────────────────────────────┘
```

---

## 10. Implementation Phases

### Phase 1: Core Group Management (MVP)
- Group CRUD (create, rename, delete, archive)
- Random name generator
- Add/remove members from agents list
- Leader designation and reassignment
- Global storage persistence
- Basic rail item UI with group list and detail views

### Phase 2: Planning & Assignment
- Mission input UI
- Leader wake-up with planning prompt
- Shared directory creation and management
- Plan parsing (YAML frontmatter)
- Assignment file generation
- Deliverable status tracking

### Phase 3: Execution & Communication
- Config injection pipeline (skills, instructions, permissions)
- Agent resume with assignment missions
- Filesystem polling monitor
- Communication log UI
- Status update display
- Badge notifications for new comms

### Phase 4: Polish & Resilience
- Stale agent detection and re-linking
- Plan parsing fallback (manual assignment UI)
- Deliverable dependency visualization
- Group archival and history
- Error recovery (agent crashes, stale state)
- Help topics and onboarding

---

## 11. Testing Strategy

### Unit Tests
- Group CRUD operations
- Name generator uniqueness and format
- Plan parsing (YAML frontmatter extraction)
- Communication message formatting
- Status file parsing

### Integration Tests (via `@clubhouse/plugin-testing`)
- `activate()` registers commands and sets up subscriptions
- Group creation persists to global storage
- Member addition with agent lookup
- Config injection calls correct `agentConfig` methods with correct `projectId`
- Monitor polling loop detects file changes (mocked)

### Manual Validation
- Create group, add agents from multiple projects
- Assign work, verify leader receives planning prompt
- Verify plan written to shared directory
- Verify members receive assignments
- Verify communication flow between agents
- Verify UI updates in real-time

---

## 12. Open Questions

1. **Should the plugin support "spectator" members?** — Agents that receive comms but aren't assigned deliverables (e.g., a QA agent that monitors progress).

2. **Should the leader agent's plan be user-approved before execution?** — Adding a review step would increase reliability but slow down the workflow. Recommend: optional "auto-execute" toggle (default: require approval).

3. **What happens when an agent is killed mid-execution?** — The plugin should detect this via `onStatusChange`, mark the member as errored, and offer the user options (reassign, retry, manual intervention).

4. **Should we support ad-hoc member addition during execution?** — Adding a new agent mid-flight would require re-planning. Recommend: allow it but require leader to re-plan.

5. **Maximum group size?** — Practical limit probably 5-7 agents. Beyond that, coordination overhead may exceed benefit. No hard limit needed for v0.1.

---

## 13. Conclusion

Buddy System is **fully feasible** with the current v0.6 API surface. The key enablers are:

- `api.agents.resume(id, { mission })` — ability to wake durable agents with specific missions
- `api.agentConfig.*` with cross-project support — inject skills, instructions, and permissions into agents across projects
- `api.agents.list()` + `api.projects.list()` — enumerate agents and projects for group composition
- `api.storage.global` — persist group state
- Filesystem-based shared directory — pragmatic inter-agent communication

No API changes or new features are required. The biggest risk is plan parsing reliability (mitigated by fallback to manual assignment) and the polling-based communication model (adequate for v0.1, upgradeable to MCP in v0.2).
